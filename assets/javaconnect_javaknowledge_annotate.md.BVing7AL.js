import{_ as a,c as t,o as n,ae as o}from"./chunks/framework.DgwfvE1J.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"javaconnect/javaknowledge/annotate.md","filePath":"javaconnect/javaknowledge/annotate.md"}'),r={name:"javaconnect/javaknowledge/annotate.md"};function s(c,e,i,l,p,d){return n(),t("div",null,[...e[0]||(e[0]=[o('<h2 id="service" tabindex="-1">@Service <a class="header-anchor" href="#service" aria-label="Permalink to &quot;@Service&quot;">​</a></h2><p>作用：配置成spring的bean，<code>@Service</code>注解点进来之后，其实就是一个@Conponent，就是把它标记成spring的一个bean。把它标记成spring的bean之后，就可以在Controller自动装配进来。</p><h2 id="controller" tabindex="-1">@Controller <a class="header-anchor" href="#controller" aria-label="Permalink to &quot;@Controller&quot;">​</a></h2><p>作用：允许接口的方法返回对象，并且对象会直接成Json文本，因为如果把当前接口返回给对应的客户端，肯定需要把后端的数据给他转换成Json文本，对应的客户端才能更好得进行处理。 <br><br></p><h2 id="requestmapping" tabindex="-1">@RequestMapping <a class="header-anchor" href="#requestmapping" aria-label="Permalink to &quot;@RequestMapping&quot;">​</a></h2><p>该注解需要给他加一级类级别的映射，即<code>@RequestMapping(&quot;/user&quot;)</code>,到时候客户端去访问我们当前的接口，即localhost:8080/user/** 来访问后面所有的接口。</p>',6)])])}const h=a(r,[["render",s]]);export{u as __pageData,h as default};
